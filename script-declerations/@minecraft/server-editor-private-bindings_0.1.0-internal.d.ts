import * as _1e from '@minecraft/server-editor-bindings';

// Enums - 10
export enum EditorRealmsServiceAvailability { DedicatedServer = 2, NoRealmsSubscription = 1, NotLoggedIn = 0, NotServerHost = 3, Success = 4, Unknown = 5};
export enum JigsawJointType { Aligned = 1, Rollable = 0};
export enum JigsawJsonType { Processor = 0, Structure = 1, StructureSet = 2, TemplatePool = 3};
export enum PersistenceGroupType { Local = 0, Replication = 1, Shared = 2};
export enum PersistenceScope { ClientGlobal = 1, ClientProject = 0, ServerGlobal = 3, ServerProject = 2};
export enum PrefabInstanceInteractionEventType { Clicked = "Clicked", Moved = "Moved"};
export enum PrefabSource { Global = "Global", Project = "Project", Unknown = "Unknown"};
export enum ProjectRegionAvailabilityMode { Loaded = 0, Ticking = 1};
export enum RealmsServiceStatus { Exporting = 2, Fetching = 0, Idle = 1, Uploading = 3};
export enum RealmsWorldUploadResult { EditorSystemFailure = 4, ExportWorldFailure = 2, Success = 1, Unknown = 0, UploadWorldFailure = 3, WorldNameNonCompliant = 6, WorldUploadBusy = 5};

// Interfaces - 16
export interface DataTransferCollectionNameData { nameStringId: string; uniqueId: string};
export interface EditorJigsawSection { bounds: _2c.BlockBoundingBox; offset: _2c.Vector3; rotation: _2c.StructureRotation; structureId: string};
export interface EditorRealmsWorld { id: string; name: string};
export interface EditorRealmsWorldSlot { id: number; name: string};
export interface EditorRegistryFile { fileJson: string; fileName: string};
export interface InputBindingInfo { actionId?: string; canRebind: boolean; label?: string; tooltip?: string};
export interface JigsawBlockData { finalBlock: string; jointType: JigsawJointType; jointTypeVisible: boolean; name: string; placementPriority: number; selectionPriority: number; target: string; targetPool: string};
export interface PersistenceGroupCreationOptions { groupType?: PersistenceGroupType; scope: PersistenceScope; version?: number};
export interface PersistenceQueryGroupOptions { namespace?: string; namespacedName?: string; scope?: PersistenceScope; version?: number};
export interface PrefabInstanceInteractionEventClicked { altPressed: boolean; ctrlPressed: boolean; shiftPressed: boolean};
export interface PrefabInstanceInteractionEventMoved { location: _2c.Vector3};
export interface PrefabServiceCreateTemplateOptions { description?: string; displayName?: string; notes?: string; tags?: string[]};
export interface PrefabTemplateAddStructureOptions { mirror?: _2c.StructureMirrorAxis; offset?: _2c.Vector3; rotation?: _2c.StructureRotation};
export interface PrefabTemplateCreateInstanceOptions { mirror?: _2c.StructureMirrorAxis; rotation?: _2c.StructureRotation};
export interface PrefabTemplateMetadata { description: string; displayName: string; instanceReferenceCount: number; name: string; notes: string; readOnly: boolean; source: PrefabSource; structureReferenceCount: number; tags: string[]; templateId: string};
export interface ProjectRegionOptions { availabilityMode?: ProjectRegionAvailabilityMode; extentX: _3e.NumberRange; extentZ: _3e.NumberRange};

// Classes - 30
export class DataStore { public readonly actionBarContainer: DataStoreActionBarContainer; public readonly actionContainer: DataStoreActionContainer; public readonly afterEvents: DataStoreAfterEvents; public readonly menuContainer: DataStoreMenuContainer; public readonly modalToolContainer: DataStoreModalToolContainer; public readonly paneContainer: DataStorePaneContainer; public sendNotificationEvent(dataTag: string, payload: string): void; private constructor();};
export class DataStoreActionBarContainer { public getItemPayload(id: string): string; public getItemProperty(id: string, property: string): (boolean | number | string | undefined); public hasItemPayload(id: string): boolean; public hasItemProperty(id: string, property: string): boolean; public registerItem(id: string, payload: string): void; public unregisterItem(id: string): void; public updateRegisteredItem(id: string, payload: string): void; public updateRegisteredItemProperty(id: string, payload: string, property: string): void; private constructor();};
export class DataStoreActionContainer { public bindActionToControl(controlId: string, actionPayload: string): void; public removeActionFromControl(controlId: string, actionPayload?: string): void; private constructor();};
export class DataStoreAfterEvents { public readonly payloadReceived: DataStorePayloadAfterEventSignal; private constructor();};
export class DataStoreMenuContainer { public createItem(id: string, payload: string): void; public destroyItem(id: string): void; public getPayload(id: string): string; public getProperty(id: string, property: string): (boolean | number | string | undefined); public hasPayload(id: string): boolean; public hasProperty(id: string, property: string): boolean; public updateItem(id: string, payload: string): void; private constructor();};
export class DataStoreModalToolActivationChangedEvent { public readonly isActive: boolean; public readonly toolId?: string; private constructor();};
export class DataStoreModalToolActivationChangedEventSignal { public subscribe(callback: (arg0: DataStoreModalToolActivationChangedEvent)=>void): (arg0: DataStoreModalToolActivationChangedEvent)=>void; public unsubscribe(callback: (arg0: DataStoreModalToolActivationChangedEvent)=>void): void; private constructor();};
export class DataStoreModalToolContainer { public readonly toolActivationChanged: DataStoreModalToolActivationChangedEventSignal; public getSelectedTool(): (string | undefined); public getToolPayload(id: string): string; public getToolProperty(id: string, property: string): (boolean | number | string | undefined); public hasToolPayload(id: string): boolean; public hasToolProperty(id: string, property: string): boolean; public registerTool(id: string, payload: string): void; public unregisterTool(id: string): void; public updateRegisteredTool(id: string, payload: string): void; public updateRegisteredToolProperty(id: string, payload: string, property: string): void; public updateSelectedTool(toolId?: string): void; private constructor();};
export class DataStorePaneContainer { public createPane(id: string): void; public destroyPane(id: string): void; private constructor();};
export class DataStorePayloadAfterEvent { public readonly dataTag: string; public readonly payload: string; private constructor();};
export class DataStorePayloadAfterEventSignal { public subscribe(callback: (arg0: DataStorePayloadAfterEvent)=>void): (arg0: DataStorePayloadAfterEvent)=>void; public unsubscribe(callback: (arg0: DataStorePayloadAfterEvent)=>void): void; private constructor();};
export class DataTransferManager { public closeSession(collectionUniqueId: string): void; public getRegisteredAccessors(): DataTransferCollectionNameData[]; public openSession(collectionUniqueId: string): void; public requestData(collectionUniqueId: string, useSnapshot?: boolean): Promise<DataTransferRequestResponse>; public sendData(collectionUniqueId: string, jsonData: string): void; public sendDataToClipboard(jsonData: string): void; private constructor();};
export class DataTransferRequestResponse { public readonly collectionName: string; public readonly data: string; public readonly schema: string; private constructor();};
export class InputService { public focusViewport(): void; public getKeyBindingProcessingState(contextId: string, bindingId: string): (number | undefined); public registerKeyBinding(contextId: string, bindingId: string, key: number, modifier: _1e.InputModifier, info: InputBindingInfo): void; public registerMouseBinding(contextId: string, bindingId: string, mouseAction: _1e.MouseActionCategory): void; public unregisterKeyBinding(contextId: string, bindingId: string): void; public unregisterMouseBinding(contextId: string, bindingId: string): void; public updateKeyBindingProcessingState(contextId: string, bindingId: string, state?: number): void; private constructor();};
export class InternalPersistenceManager { public createGroup(namespacedName: string, options: PersistenceGroupCreationOptions): PersistenceGroup; public deleteGroup(namespacedName: string, options: PersistenceGroupCreationOptions): void; public disposeAllGroups(): void; public fetchGroups(options: PersistenceQueryGroupOptions): PersistenceGroup[]; public getGroup(namespacedName: string, options: PersistenceGroupCreationOptions): (PersistenceGroup | undefined); public getOrCreateGroup(namespacedName: string, options: PersistenceGroupCreationOptions): PersistenceGroup; public requestClientGroup(namespacedName: string, options: PersistenceGroupCreationOptions, callback: (arg0?: PersistenceGroup)=>void): void; private constructor();};
export class InternalPlayerServiceContext { public readonly dataStore: DataStore; public readonly dataTransfer: DataTransferManager; public readonly input: InputService; public readonly internalPersistenceManager: InternalPersistenceManager; public readonly jigsawService: JigsawService; public readonly prefabManager: PrefabManager; public readonly realmsService: RealmsService; public readonly regionManager: ProjectRegionManager; private constructor();};
export class JigsawService { public generateJigsaw(registryName: string, startingPool: string, startTarget: string, seed: _2c.Vector3, depth: number, maxHorizontalDistanceFromCenter: number, validateRegistry: boolean, clipboardItem: _1e.ClipboardItem): Promise<EditorJigsawSection[]>; public getEmptyRegistryFiles(): Record<string,string>; public getExportLocation(): string; public getJigsawBlockData(pos: _2c.Vector3): JigsawBlockData; public getRegistryData(registryName: string): Record<string,EditorRegistryFile[]>; public getRegistryList(): string[]; public setJigsawBlockData(pos: _2c.Vector3, jigsawData: JigsawBlockData): void; public setRegistryData(registryName: string, processorData: EditorRegistryFile[], structureData: EditorRegistryFile[], structureSetData: EditorRegistryFile[], templatePoolData: EditorRegistryFile[]): Promise<string[]>; private constructor();};
export class MinecraftEditorInternal { public readonly isNewLevel: boolean; public fireTelemetryEvent(player: _2c.Player, source: string, eventName: string, metadata: string): void; public getPlayerServices(player: _2c.Player): InternalPlayerServiceContext; public registerExtension(extensionName: string, activationFunction: (arg0: _1e.ExtensionContext)=>void, shutdownFunction: (arg0: _1e.ExtensionContext)=>void, options?: _1e.ExtensionOptionalParameters): _1e.Extension; private constructor();};
export class PersistenceGroup { public createItem(itemName: string, defaultJsonValue?: string): PersistenceGroupItem; public deleteItem(itemName: string): void; public dispose(): boolean; public disposeAllGroupItems(): void; public disposeGroupItem(key: string): boolean; public fetchItem(itemName: string): (PersistenceGroupItem | undefined); public getOrCreateItem(itemName: string, defaultJsonValue?: string): PersistenceGroupItem; public listItems(): string[]; private constructor();};
export class PersistenceGroupItem { public commit(): void; public getAsJSON(): string; public getKey(): string; public getValue(): string; public setValue(value: string): void; private constructor();};
export class PrefabInstanceInteractionEvent { public readonly eventData: PrefabInstanceInteractionEventClicked | PrefabInstanceInteractionEventMoved; public readonly eventType: PrefabInstanceInteractionEventType; public readonly instance: PrefabTemplateInstance; private constructor();};
export class PrefabManager { public readonly instanceInteractionEvents: PrefabServiceInstanceInteractionEvent; public beginCapturingMouseClicks(): void; public clearSelectedInstances(): void; public cloneTemplate(templateOrMetadataToClone: PrefabTemplate | PrefabTemplateMetadata, newName: string, optionalNewDisplayName?: string): PrefabTemplate; public createTemplate(name: string, options?: PrefabServiceCreateTemplateOptions): PrefabTemplate; public deleteInstance(instance: PrefabTemplateInstance): void; public deleteTemplate(templateOrMetadata: PrefabTemplate | PrefabTemplateMetadata): void; public deselectInstance(instance: PrefabTemplateInstance): void; public endCapturingMouseClicks(): void; public getTemplate(searchMetadata_or_fullyQualifiedName: PrefabTemplateMetadata | string): PrefabTemplate; public getTemplateList(): PrefabTemplateMetadata[]; public selectInstance(instance: PrefabTemplateInstance, append: boolean): void; private constructor();};
export class PrefabServiceInstanceInteractionEvent { public subscribe(callback: (arg0: PrefabInstanceInteractionEvent)=>void): (arg0: PrefabInstanceInteractionEvent)=>void; public unsubscribe(callback: (arg0: PrefabInstanceInteractionEvent)=>void): void; private constructor();};
export class PrefabTemplate { public description: string; public displayName: string; public readonly instanceCount: number; public readonly name: string; public notes: string; public readonly source: PrefabSource; public addStructure(structure: _1e.EditorStructure, options?: PrefabTemplateAddStructureOptions): PrefabTemplateStructure; public createInstance(location: _2c.Vector3, options?: PrefabTemplateCreateInstanceOptions): PrefabTemplateInstance; public getMetadata(): PrefabTemplateMetadata; public getTags(): string[]; public getTemplateStructures(): PrefabTemplateStructure[]; public removeStructure(templateStructure: PrefabTemplateStructure): void; public setName(newName: string): void; public setTags(newTags: string[]): void; private constructor();};
export class PrefabTemplateInstance { public instanceMirror: _2c.StructureMirrorAxis; public instanceRotation: _2c.StructureRotation; public location: _2c.Vector3; public bakeInstance(): void; public getStructureRefs(): PrefabTemplateInstanceStructure[]; public getTemplate(): PrefabTemplate; private constructor();};
export class PrefabTemplateInstanceStructure { public instanceMirror: _2c.StructureMirrorAxis; public instanceRotation: _2c.StructureRotation; public getTemplateStructure(): PrefabTemplateStructure; private constructor();};
export class PrefabTemplateStructure { public readonly id: string; public instanceMirror: _2c.StructureMirrorAxis; public instanceOffset: _2c.Vector3; public instanceRotation: _2c.StructureRotation; public readonly structureNormalizedOrigin: _2c.Vector3; public readonly structureOffset: _2c.Vector3; public readonly structureSize: _2c.Vector3; public getStructure(): _1e.EditorStructure; private constructor();};
export class ProjectRegion { public readonly availabilityMode: ProjectRegionAvailabilityMode; public readonly id: string; public readonly isValid: boolean; public dispose(): boolean; public getAvailableLocationFromRay(location: _2c.Vector3, direction: _2c.Vector3, options?: _2c.BlockRaycastOptions): (_2c.Vector3 | undefined); public getBlock(location: _2c.Vector3): (_2c.Block | undefined); public getBlockMapColor(location: _2c.Vector3): _2c.RGBA; public getBlockPermutation(location: _2c.Vector3): _2c.BlockPermutation; public getBlockTypeId(location: _2c.Vector3): string; public getBounds(): _2c.BlockBoundingBox; public isAirBlock(location: _2c.Vector3): boolean; public isAreaAvailable(boundingBox: _2c.BlockBoundingBox): boolean; public isAvailable(): boolean; public isBlockWaterLogged(location: _2c.Vector3): boolean; public isLiquidBlock(location: _2c.Vector3): boolean; public isLocationAvailable(location: _2c.Vector3): boolean; public isSolidBlock(location: _2c.Vector3): boolean; public requestBlockOperationArea(volume: _1e.RelativeVolumeListBlockVolume, callback: (arg0: _2c.BlockLocationIterator)=>void): Promise<void>; public requestExpandToContain(extentX: _3e.NumberRange, extentZ: _3e.NumberRange): Promise<void>; public requestExtentsUpdate(extentX: _3e.NumberRange, extentZ: _3e.NumberRange): Promise<void>; public requestMove(center: _2c.Vector3): Promise<void>; public setBlockType(location: _2c.Vector3, blockType: _2c.BlockType | string): void; public setBlockWaterlogged(location: _2c.Vector3, isWaterlogged: boolean): void; public spawnEntity(identifier: _2c.EntityType | string, location: _2c.Vector3, rotation?: number): _2c.Entity; public waitUntilAvailable(): Promise<void>; public waitUntilBoundsAvailable(boundingBox: _2c.BlockBoundingBox): Promise<void>; private constructor();};
export class ProjectRegionManager { public disposeAllRegions(): void; public disposeRegion(id: string): boolean; public getCursorRegion(): ProjectRegion; public getSelectionRegion(): ProjectRegion; public leaseRegion(options: ProjectRegionOptions): ProjectRegion; private constructor();};
export class RealmsService { public beginDownloadFromRealms(realmsWorldId: string, slotId: number): Promise<string>; public beginUploadToRealms(realmsWorldId: string, slotId: number, gameOptions: _1e.GameOptions): Promise<RealmsWorldUploadResult>; public canUploadWorld(): boolean; public getRealmWorldlist(): Promise<EditorRealmsWorld[]>; public getServiceStatus(): RealmsServiceStatus; public getSlots(worldId: string): Promise<EditorRealmsWorldSlot[]>; public isRealmsServiceAvailable(): EditorRealmsServiceAvailability; private constructor();};

// Constants & Objects - 1

export const editorInternal: MinecraftEditorInternal;

// Functions - 0

// Errors - 10
export class PrefabErrorInvalidInstance extends Error{ private constructor();};
export class PrefabErrorInvalidName extends Error{ private constructor();};
export class PrefabErrorInvalidStructure extends Error{ private constructor();};
export class PrefabErrorInvalidTemplate extends Error{ private constructor();};
export class PrefabErrorInvalidTemplateStructure extends Error{ private constructor();};
export class PrefabErrorStringInvalidLength extends Error{ public readonly length: number; public readonly maxLength: number; public readonly string: string; private constructor();};
export class PrefabErrorValueOutOfBounds extends Error{ private constructor();};
export class PrefabServiceError extends Error{ private constructor();};
export class PrefabTemplateExists extends Error{ private constructor();};
export class PrefabTemplateNotFound extends Error{ private constructor();};
