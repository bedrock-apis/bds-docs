
// Enums - 5
export enum GameTestCompletedErrorReason { Cleanup = "Cleanup", Done = "Done"};
export enum GameTestErrorType { Assert = "Assert", AssertAtPosition = "AssertAtPosition", ExecutionTimeout = "ExecutionTimeout", ExhaustedAttempts = "ExhaustedAttempts", FailConditionsMet = "FailConditionsMet", LevelStateModificationFailed = "LevelStateModificationFailed", MethodNotImplemented = "MethodNotImplemented", SimulatedPlayerOutOfBounds = "SimulatedPlayerOutOfBounds", Unknown = "Unknown", Waiting = "Waiting"};
export enum LookDuration { Continuous = "Continuous", Instant = "Instant", UntilMove = "UntilMove"};
export enum PersonaArmSize { Slim = "Slim", Wide = "Wide"};
export enum PersonaPieceType { Arms = "Arms", Back = "Back", Body = "Body", Bottom = "Bottom", Capes = "Capes", Dress = "Dress", Eyes = "Eyes", FaceAccessory = "FaceAccessory", FacialHair = "FacialHair", Feet = "Feet", Hair = "Hair", Hands = "Hands", Head = "Head", HighPants = "HighPants", Hood = "Hood", LeftArm = "LeftArm", LeftLeg = "LeftLeg", Legs = "Legs", Mouth = "Mouth", Outerwear = "Outerwear", RightArm = "RightArm", RightLeg = "RightLeg", Skeleton = "Skeleton", Skin = "Skin", Top = "Top"};

// Interfaces - 4
export interface GameTestErrorContext { absolutePosition: _1e.Vector3; relativePosition: _1e.Vector3; tickCount: number};
export interface MoveToOptions { faceTarget?: boolean; speed?: number};
export interface PlayerPersonaPiece { id: string; isDefaultPiece?: boolean; packId: string; productId: string; type: PersonaPieceType};
export interface PlayerSkinData { armSize?: PersonaArmSize; personaPieces?: PlayerPersonaPiece[]; skinColor?: _1e.RGB};

// Classes - 8
export class FenceConnectivity { public readonly east: boolean; public readonly north: boolean; public readonly south: boolean; public readonly west: boolean; private constructor();};
export class GameTestSequence { public thenExecute(callback: ()=>void): GameTestSequence; public thenExecuteAfter(delayTicks: number, callback: ()=>void): GameTestSequence; public thenExecuteFor(tickCount: number, callback: ()=>void): GameTestSequence; public thenFail(errorMessage: string): void; public thenIdle(delayTicks: number): GameTestSequence; public thenSucceed(): void; public thenWait(callback: ()=>void): GameTestSequence; public thenWaitAfter(delayTicks: number, callback: ()=>void): GameTestSequence; private constructor();};
export class NavigationResult { public readonly isFullPath: boolean; public getPath(): _1e.Vector3[]; private constructor();};
export class RegistrationBuilder { public batch(batchName: string): RegistrationBuilder; public maxAttempts(attemptCount: number): RegistrationBuilder; public maxTicks(tickCount: number): RegistrationBuilder; public padding(paddingBlocks: number): RegistrationBuilder; public required(isRequired: boolean): RegistrationBuilder; public requiredSuccessfulAttempts(attemptCount: number): RegistrationBuilder; public rotateTest(rotate: boolean): RegistrationBuilder; public setupTicks(tickCount: number): RegistrationBuilder; public structureLocation(structureLocation: _1e.Vector3, structureDimension?: _1e.DimensionType | string): RegistrationBuilder; public structureName(structureName: string): RegistrationBuilder; public tag(tag: string): RegistrationBuilder; private constructor();};
export class SculkSpreader { public readonly maxCharge: number; public addCursorsWithOffset(offset: _1e.Vector3, charge: number): void; public getCursorPosition(index: number): _1e.Vector3; public getNumberOfCursors(): number; public getTotalCharge(): number; private constructor();};
//@ts-ignore extending for classes with private constructor is possible with native API
export class SimulatedPlayer extends _1e.Player{ public readonly headRotation: _1e.Vector2; public isSprinting: boolean; public attack(): boolean; public attackEntity(entity: _1e.Entity): boolean; public breakBlock(blockLocation: _1e.Vector3, direction?: _1e.Direction): boolean; public chat(message: string): void; public disconnect(): void; public dropSelectedItem(): boolean; public fly(): void; public giveItem(itemStack: _1e.ItemStack, selectSlot?: boolean): boolean; public glide(): boolean; public interact(): boolean; public interactWithBlock(blockLocation: _1e.Vector3, direction?: _1e.Direction): boolean; public interactWithEntity(entity: _1e.Entity): boolean; public jump(): boolean; public lookAtBlock(blockLocation: _1e.Vector3, duration?: LookDuration): void; public lookAtEntity(entity: _1e.Entity, duration?: LookDuration): void; public lookAtLocation(location: _1e.Vector3, duration?: LookDuration): void; public move(westEast: number, northSouth: number, speed?: number): void; public moveRelative(leftRight: number, backwardForward: number, speed?: number): void; public moveToBlock(blockLocation: _1e.Vector3, options?: MoveToOptions): void; public moveToLocation(location: _1e.Vector3, options?: MoveToOptions): void; public navigateToBlock(blockLocation: _1e.Vector3, speed?: number): NavigationResult; public navigateToEntity(entity: _1e.Entity, speed?: number): NavigationResult; public navigateToLocation(location: _1e.Vector3, speed?: number): NavigationResult; public navigateToLocations(locations: _1e.Vector3[], speed?: number): void; public respawn(): boolean; public rotateBody(angleInDegrees: number): void; public setBodyRotation(angleInDegrees: number): void; public setItem(itemStack: _1e.ItemStack, slot: number, selectSlot?: boolean): boolean; public setSkin(options: PlayerSkinData): void; public startBuild(slot?: number): void; public stopBreakingBlock(): void; public stopBuild(): void; public stopFlying(): void; public stopGliding(): void; public stopInteracting(): void; public stopMoving(): void; public stopSwimming(): void; public stopUsingItem(): (_1e.ItemStack | undefined); public swim(): void; public useItem(itemStack: _1e.ItemStack): boolean; public useItemInSlot(slot: number): boolean; public useItemInSlotOnBlock(slot: number, blockLocation: _1e.Vector3, direction?: _1e.Direction, faceLocation?: _1e.Vector3): boolean; public useItemOnBlock(itemStack: _1e.ItemStack, blockLocation: _1e.Vector3, direction?: _1e.Direction, faceLocation?: _1e.Vector3): boolean; private constructor();};
export class Tags { public static readonly suiteAll = "suite:all"; public static readonly suiteDebug = "suite:debug"; public static readonly suiteDefault = "suite:default"; public static readonly suiteDisabled = "suite:disabled"; public static readonly suiteNextUpdate = "suite:nextupdate"; private constructor();};
export class Test { public assert(condition: boolean, message: string): void; public assertBlockPresent(blockType: _1e.BlockType | string, blockLocation: _1e.Vector3, isPresent?: boolean): void; public assertBlockState(blockLocation: _1e.Vector3, callback: (arg0: _1e.Block)=>boolean): void; public assertCanReachLocation(mob: _1e.Entity, blockLocation: _1e.Vector3, canReach?: boolean): void; public assertContainerContains(itemStack: _1e.ItemStack, blockLocation: _1e.Vector3): void; public assertContainerEmpty(blockLocation: _1e.Vector3): void; public assertEntityHasArmor(entityTypeIdentifier: string, armorSlot: number, armorName: string, armorData: number, blockLocation: _1e.Vector3, hasArmor?: boolean): void; public assertEntityHasComponent(entityTypeIdentifier: string, componentIdentifier: string, blockLocation: _1e.Vector3, hasComponent?: boolean): void; public assertEntityInstancePresent(entity: _1e.Entity, blockLocation: _1e.Vector3, isPresent?: boolean): void; public assertEntityInstancePresentInArea(entity: _1e.Entity, isPresent?: boolean): void; public assertEntityPresent(entityTypeIdentifier: string, blockLocation: _1e.Vector3, searchDistance?: number, isPresent?: boolean): void; public assertEntityPresentInArea(entityTypeIdentifier: string, isPresent?: boolean): void; public assertEntityState(blockLocation: _1e.Vector3, entityTypeIdentifier: string, callback: (arg0: _1e.Entity)=>boolean): void; public assertEntityTouching(entityTypeIdentifier: string, location: _1e.Vector3, isTouching?: boolean): void; public assertIsWaterlogged(blockLocation: _1e.Vector3, isWaterlogged?: boolean): void; public assertItemEntityCountIs(itemType: _1e.ItemType | string, blockLocation: _1e.Vector3, searchDistance: number, count: number): void; public assertItemEntityPresent(itemType: _1e.ItemType | string, blockLocation: _1e.Vector3, searchDistance?: number, isPresent?: boolean): void; public assertRedstonePower(blockLocation: _1e.Vector3, power: number): void; public destroyBlock(blockLocation: _1e.Vector3, dropResources?: boolean): void; public fail(errorMessage: string): void; public failIf(callback: ()=>void): void; public getBlock(blockLocation: _1e.Vector3): _1e.Block; public getDimension(): _1e.Dimension; public getFenceConnectivity(blockLocation: _1e.Vector3): FenceConnectivity; public getSculkSpreader(blockLocation: _1e.Vector3): (SculkSpreader | undefined); public getTestDirection(): _1e.Direction; public idle(tickDelay: number): Promise<void>; public isCleaningUp(): boolean; public isCompleted(): boolean; public killAllEntities(): void; public onPlayerJump(mob: _1e.Entity, jumpAmount: number): void; public pressButton(blockLocation: _1e.Vector3): void; public print(text: string): void; public pullLever(blockLocation: _1e.Vector3): void; public pulseRedstone(blockLocation: _1e.Vector3, duration: number): void; public relativeBlockLocation(worldBlockLocation: _1e.Vector3): _1e.Vector3; public relativeLocation(worldLocation: _1e.Vector3): _1e.Vector3; public removeSimulatedPlayer(simulatedPlayer: SimulatedPlayer): void; public rotateDirection(direction: _1e.Direction): _1e.Direction; public rotateVector(vector: _1e.Vector3): _1e.Vector3; public runAfterDelay(delayTicks: number, callback: ()=>void): void; public runAtTickTime(tick: number, callback: ()=>void): void; public runOnFinish(callback: ()=>void): void; public setBlockPermutation(blockData: _1e.BlockPermutation, blockLocation: _1e.Vector3): void; public setBlockType(blockType: _1e.BlockType | string, blockLocation: _1e.Vector3): void; public setFluidContainer(location: _1e.Vector3, type: _1e.FluidType): void; public setTntFuse(entity: _1e.Entity, fuseLength: number): void; public spawn(entityTypeIdentifier: string, blockLocation: _1e.Vector3): _1e.Entity; public spawnAtLocation(entityTypeIdentifier: string, location: _1e.Vector3): _1e.Entity; public spawnItem(itemStack: _1e.ItemStack, location: _1e.Vector3): _1e.Entity; public spawnSimulatedPlayer(blockLocation: _1e.Vector3, name?: string, gameMode?: _1e.GameMode): SimulatedPlayer; public spawnWithoutBehaviors(entityTypeIdentifier: string, blockLocation: _1e.Vector3): _1e.Entity; public spawnWithoutBehaviorsAtLocation(entityTypeIdentifier: string, location: _1e.Vector3): _1e.Entity; public spreadFromFaceTowardDirection(blockLocation: _1e.Vector3, fromFace: _1e.Direction, direction: _1e.Direction): void; public startSequence(): GameTestSequence; public succeed(): void; public succeedIf(callback: ()=>void): void; public succeedOnTick(tick: number): void; public succeedOnTickWhen(tick: number, callback: ()=>void): void; public succeedWhen(callback: ()=>void): void; public succeedWhenBlockPresent(blockType: _1e.BlockType | string, blockLocation: _1e.Vector3, isPresent?: boolean): void; public succeedWhenEntityHasComponent(entityTypeIdentifier: string, componentIdentifier: string, blockLocation: _1e.Vector3, hasComponent: boolean): void; public succeedWhenEntityPresent(entityTypeIdentifier: string, blockLocation: _1e.Vector3, isPresent?: boolean): void; public triggerInternalBlockEvent(blockLocation: _1e.Vector3, event: string, eventParameters?: number[]): void; public until(callback: ()=>void): Promise<void>; public walkTo(mob: _1e.Entity, blockLocation: _1e.Vector3, speedModifier?: number): void; public walkToLocation(mob: _1e.Entity, location: _1e.Vector3, speedModifier?: number): void; public worldBlockLocation(relativeBlockLocation: _1e.Vector3): _1e.Vector3; public worldLocation(relativeLocation: _1e.Vector3): _1e.Vector3; private constructor();};

// Constants & Objects - 0


// Functions - 4
export function getPlayerSkin(player: _1e.Player): PlayerSkinData
export function register(testClassName: string, testName: string, testFunction: (arg0: Test)=>void): RegistrationBuilder
export function registerAsync(testClassName: string, testName: string, testFunction: (arg0: Test)=>Promise<void>): RegistrationBuilder
export function spawnSimulatedPlayer(location: _1e.DimensionLocation, name: string, gameMode?: _1e.GameMode): SimulatedPlayer

// Errors - 2
export class GameTestCompletedError extends Error{ public readonly reason: GameTestCompletedErrorReason; private constructor();};
export class GameTestError extends Error{ public readonly context?: GameTestErrorContext; public readonly messageParameters: string[]; public readonly type: GameTestErrorType; private constructor();};
